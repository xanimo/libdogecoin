<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdogecoin: src/libevent/buffer_iocp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdogecoin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_97979c17d049e8002d2e089c4964ead4.html">libevent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">buffer_iocp.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;event2/event-config.h&quot;</code><br />
<code>#include &quot;evconfig-private.h&quot;</code><br />
<code>#include &quot;event2/buffer.h&quot;</code><br />
<code>#include &quot;event2/buffer_compat.h&quot;</code><br />
<code>#include &quot;event2/util.h&quot;</code><br />
<code>#include &quot;event2/thread.h&quot;</code><br />
<code>#include &quot;<a class="el" href="util-internal_8h_source.html">util-internal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="evthread-internal_8h_source.html">evthread-internal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="evbuffer-internal_8h_source.html">evbuffer-internal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iocp-internal_8h_source.html">iocp-internal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mm-internal_8h_source.html">mm-internal.h</a>&quot;</code><br />
<code>#include &lt;winsock2.h&gt;</code><br />
<code>#include &lt;winerror.h&gt;</code><br />
<code>#include &lt;windows.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
</div>
<p><a href="buffer__iocp_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer__overlapped.html">evbuffer_overlapped</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2392eb7397eb609061e172efebbe1f22"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:a2392eb7397eb609061e172efebbe1f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3499e3a8f974c5116ffac6aec8a211"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a> (struct <a class="el" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *eo, unsigned flag)</td></tr>
<tr class="separator:abd3499e3a8f974c5116ffac6aec8a211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521d50f618504e83c187ba3a3dafce08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#a521d50f618504e83c187ba3a3dafce08">evbuffer_commit_read_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_ssize_t nBytes)</td></tr>
<tr class="separator:a521d50f618504e83c187ba3a3dafce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef54252bf93bc02e864d887556c961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#adbef54252bf93bc02e864d887556c961">evbuffer_commit_write_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_ssize_t nBytes)</td></tr>
<tr class="separator:adbef54252bf93bc02e864d887556c961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473ad3c37c6b8af9f56f9ccda2a2ac8d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#a473ad3c37c6b8af9f56f9ccda2a2ac8d">evbuffer_overlapped_new_</a> (evutil_socket_t fd)</td></tr>
<tr class="separator:a473ad3c37c6b8af9f56f9ccda2a2ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2f1c3f3a08955cf2a209dd3549efe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#aea2f1c3f3a08955cf2a209dd3549efe7">evbuffer_launch_write_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t at_most, struct <a class="el" href="structevent__overlapped.html">event_overlapped</a> *ol)</td></tr>
<tr class="separator:aea2f1c3f3a08955cf2a209dd3549efe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad818d436374dfa11f65abb2ac42d0f61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#ad818d436374dfa11f65abb2ac42d0f61">evbuffer_launch_read_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, size_t at_most, struct <a class="el" href="structevent__overlapped.html">event_overlapped</a> *ol)</td></tr>
<tr class="separator:ad818d436374dfa11f65abb2ac42d0f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffb1fe62fb6146de08b63dce4597a53"><td class="memItemLeft" align="right" valign="top">evutil_socket_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#aaffb1fe62fb6146de08b63dce4597a53">evbuffer_overlapped_get_fd_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr class="separator:aaffb1fe62fb6146de08b63dce4597a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93de139bbf95596c3018542c8bfb45a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buffer__iocp_8c.html#a93de139bbf95596c3018542c8bfb45a8">evbuffer_overlapped_set_fd_</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf, evutil_socket_t fd)</td></tr>
<tr class="separator:a93de139bbf95596c3018542c8bfb45a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This module implements overlapped read and write functions for evbuffer objects on Windows. </p>

<p class="definition">Definition in file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe" name="a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">&#9670;&nbsp;</a></span>MAX_WSABUFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_WSABUFS&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00051">51</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a521d50f618504e83c187ba3a3dafce08" name="a521d50f618504e83c187ba3a3dafce08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521d50f618504e83c187ba3a3dafce08">&#9670;&nbsp;</a></span>evbuffer_commit_read_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_commit_read_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>evbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >XXX document </p>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00098">98</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   99</span>{</div>
<div class="line"><span class="lineno">  100</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(evbuf);</div>
<div class="line"><span class="lineno">  101</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__chain.html">evbuffer_chain</a> **chainp;</div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordtype">size_t</span> remaining, len;</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordtype">unsigned</span> i;</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a>(evbuf);</div>
<div class="line"><span class="lineno">  106</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a> &amp;&amp; !buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a>);</div>
<div class="line"><span class="lineno">  107</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(nBytes &gt;= 0); <span class="comment">/* XXXX Can this be false? */</span></div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#ae1aa94b12221a02fcacc2f5dbf0f28b5">evbuffer_unfreeze</a>(evbuf, 0);</div>
<div class="line"><span class="lineno">  110</span> </div>
<div class="line"><span class="lineno">  111</span>    chainp = evbuf-&gt;<a class="code hl_variable" href="structevbuffer.html#aa89b72c7086750d7b6c91902e2f1bf21">last_with_datap</a>;</div>
<div class="line"><span class="lineno">  112</span>    <span class="keywordflow">if</span> (!((*chainp)-&gt;flags &amp; <a class="code hl_define" href="evbuffer-internal_8h.html#a07f97541f1b57f6ab70af2c555749161">EVBUFFER_MEM_PINNED_R</a>))</div>
<div class="line"><span class="lineno">  113</span>        chainp = &amp;(*chainp)-&gt;<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>;</div>
<div class="line"><span class="lineno">  114</span>    remaining = nBytes;</div>
<div class="line"><span class="lineno">  115</span>    <span class="keywordflow">for</span> (i = 0; remaining &gt; 0 &amp;&amp; i &lt; (unsigned)buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a>; ++i) {</div>
<div class="line"><span class="lineno">  116</span>        <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(*chainp);</div>
<div class="line"><span class="lineno">  117</span>        len = buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>[i].len;</div>
<div class="line"><span class="lineno">  118</span>        <span class="keywordflow">if</span> (remaining &lt; len)</div>
<div class="line"><span class="lineno">  119</span>            len = remaining;</div>
<div class="line"><span class="lineno">  120</span>        (*chainp)-&gt;off += len;</div>
<div class="line"><span class="lineno">  121</span>        evbuf-&gt;<a class="code hl_variable" href="structevbuffer.html#aa89b72c7086750d7b6c91902e2f1bf21">last_with_datap</a> = chainp;</div>
<div class="line"><span class="lineno">  122</span>        remaining -= len;</div>
<div class="line"><span class="lineno">  123</span>        chainp = &amp;(*chainp)-&gt;<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>;</div>
<div class="line"><span class="lineno">  124</span>    }</div>
<div class="line"><span class="lineno">  125</span> </div>
<div class="line"><span class="lineno">  126</span>    <a class="code hl_function" href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a>(buf, <a class="code hl_define" href="evbuffer-internal_8h.html#a07f97541f1b57f6ab70af2c555749161">EVBUFFER_MEM_PINNED_R</a>);</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>    buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a> = 0;</div>
<div class="line"><span class="lineno">  129</span> </div>
<div class="line"><span class="lineno">  130</span>    evbuf-&gt;<a class="code hl_variable" href="structevbuffer.html#af432b67ab2e1b3dd8b96e314a0785116">total_len</a> += nBytes;</div>
<div class="line"><span class="lineno">  131</span>    evbuf-&gt;<a class="code hl_variable" href="structevbuffer.html#ab2953dce6411c80514f7c787b311725c">n_add_for_cb</a> += nBytes;</div>
<div class="line"><span class="lineno">  132</span> </div>
<div class="line"><span class="lineno">  133</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a19e27adc7ac1c3b2c8303586c39e912e">evbuffer_invoke_callbacks_</a>(evbuf);</div>
<div class="line"><span class="lineno">  134</span> </div>
<div class="line"><span class="lineno">  135</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a3ac07b1be4b6fe0b2aa6a1677b060a80">evbuffer_decref_and_unlock_</a>(evbuf);</div>
<div class="line"><span class="lineno">  136</span>}</div>
<div class="ttc" id="abuffer__iocp_8c_html_a2392eb7397eb609061e172efebbe1f22"><div class="ttname"><a href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a></div><div class="ttdeci">static struct evbuffer_overlapped * upcast_evbuffer(struct evbuffer *buf)</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00075">buffer_iocp.c:75</a></div></div>
<div class="ttc" id="abuffer__iocp_8c_html_abd3499e3a8f974c5116ffac6aec8a211"><div class="ttname"><a href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a></div><div class="ttdeci">static void pin_release(struct evbuffer_overlapped *eo, unsigned flag)</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00084">buffer_iocp.c:84</a></div></div>
<div class="ttc" id="aevbuffer-internal_8h_html_a07f97541f1b57f6ab70af2c555749161"><div class="ttname"><a href="evbuffer-internal_8h.html#a07f97541f1b57f6ab70af2c555749161">EVBUFFER_MEM_PINNED_R</a></div><div class="ttdeci">#define EVBUFFER_MEM_PINNED_R</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00195">evbuffer-internal.h:195</a></div></div>
<div class="ttc" id="aevbuffer-internal_8h_html_a2db7168a100510b09c26d9d9896991e0"><div class="ttname"><a href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a></div><div class="ttdeci">#define EVBUFFER_LOCK(buffer)</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00285">evbuffer-internal.h:285</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a19e27adc7ac1c3b2c8303586c39e912e"><div class="ttname"><a href="libevent_2buffer_8c.html#a19e27adc7ac1c3b2c8303586c39e912e">evbuffer_invoke_callbacks_</a></div><div class="ttdeci">void evbuffer_invoke_callbacks_(struct evbuffer *buffer)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00514">buffer.c:514</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a3ac07b1be4b6fe0b2aa6a1677b060a80"><div class="ttname"><a href="libevent_2buffer_8c.html#a3ac07b1be4b6fe0b2aa6a1677b060a80">evbuffer_decref_and_unlock_</a></div><div class="ttdeci">void evbuffer_decref_and_unlock_(struct evbuffer *buffer)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00561">buffer.c:561</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_ae1aa94b12221a02fcacc2f5dbf0f28b5"><div class="ttname"><a href="libevent_2buffer_8c.html#ae1aa94b12221a02fcacc2f5dbf0f28b5">evbuffer_unfreeze</a></div><div class="ttdeci">int evbuffer_unfreeze(struct evbuffer *buffer, int start)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l03413">buffer.c:3413</a></div></div>
<div class="ttc" id="astructevbuffer__chain_html"><div class="ttname"><a href="structevbuffer__chain.html">evbuffer_chain</a></div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00171">evbuffer-internal.h:171</a></div></div>
<div class="ttc" id="astructevbuffer__chain_html_a302eea17a6aacc55c33f119ad788ddb5"><div class="ttname"><a href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">evbuffer_chain::next</a></div><div class="ttdeci">struct evbuffer_chain * next</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00173">evbuffer-internal.h:173</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html"><div class="ttname"><a href="structevbuffer__overlapped.html">evbuffer_overlapped</a></div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00054">buffer_iocp.c:54</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a063b9ed7a996656f391abaf6ad157344"><div class="ttname"><a href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">evbuffer_overlapped::buffers</a></div><div class="ttdeci">WSABUF buffers[MAX_WSABUFS]</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00069">buffer_iocp.c:69</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a07693e76fedfbd0227a2591c62749867"><div class="ttname"><a href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">evbuffer_overlapped::write_in_progress</a></div><div class="ttdeci">unsigned write_in_progress</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00061">buffer_iocp.c:61</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a0d572b7b2208fa8ae9af987879077f4e"><div class="ttname"><a href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">evbuffer_overlapped::read_in_progress</a></div><div class="ttdeci">unsigned read_in_progress</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00060">buffer_iocp.c:60</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a5418e2c9cd900c2135fe3320ad300b11"><div class="ttname"><a href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">evbuffer_overlapped::n_buffers</a></div><div class="ttdeci">int n_buffers</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00068">buffer_iocp.c:68</a></div></div>
<div class="ttc" id="astructevbuffer_html_aa89b72c7086750d7b6c91902e2f1bf21"><div class="ttname"><a href="structevbuffer.html#aa89b72c7086750d7b6c91902e2f1bf21">evbuffer::last_with_datap</a></div><div class="ttdeci">struct evbuffer_chain ** last_with_datap</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00099">evbuffer-internal.h:99</a></div></div>
<div class="ttc" id="astructevbuffer_html_ab2953dce6411c80514f7c787b311725c"><div class="ttname"><a href="structevbuffer.html#ab2953dce6411c80514f7c787b311725c">evbuffer::n_add_for_cb</a></div><div class="ttdeci">size_t n_add_for_cb</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00106">evbuffer-internal.h:106</a></div></div>
<div class="ttc" id="astructevbuffer_html_af432b67ab2e1b3dd8b96e314a0785116"><div class="ttname"><a href="structevbuffer.html#af432b67ab2e1b3dd8b96e314a0785116">evbuffer::total_len</a></div><div class="ttdeci">size_t total_len</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00102">evbuffer-internal.h:102</a></div></div>
<div class="ttc" id="autil-internal_8h_html_a7365930d8b30f4c1ab3cef31a8622731"><div class="ttname"><a href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a></div><div class="ttdeci">#define EVUTIL_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> <a href="util-internal_8h_source.html#l00363">util-internal.h:363</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__iocp_8c_source.html#l00069">evbuffer_overlapped::buffers</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00561">evbuffer_decref_and_unlock_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00514">evbuffer_invoke_callbacks_()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00285">EVBUFFER_LOCK</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00195">EVBUFFER_MEM_PINNED_R</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03413">evbuffer_unfreeze()</a>, <a class="el" href="util-internal_8h_source.html#l00363">EVUTIL_ASSERT</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00099">evbuffer::last_with_datap</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00106">evbuffer::n_add_for_cb</a>, <a class="el" href="buffer__iocp_8c_source.html#l00068">evbuffer_overlapped::n_buffers</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00173">evbuffer_chain::next</a>, <a class="el" href="buffer__iocp_8c_source.html#l00084">pin_release()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00060">evbuffer_overlapped::read_in_progress</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00102">evbuffer::total_len</a>, <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00061">evbuffer_overlapped::write_in_progress</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00461">read_complete()</a>.</p>

</div>
</div>
<a id="adbef54252bf93bc02e864d887556c961" name="adbef54252bf93bc02e864d887556c961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef54252bf93bc02e864d887556c961">&#9670;&nbsp;</a></span>evbuffer_commit_write_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_commit_write_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>evbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00139">139</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  140</span>{</div>
<div class="line"><span class="lineno">  141</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(evbuf);</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a>(evbuf);</div>
<div class="line"><span class="lineno">  144</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a> &amp;&amp; !buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a>);</div>
<div class="line"><span class="lineno">  145</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#ae1aa94b12221a02fcacc2f5dbf0f28b5">evbuffer_unfreeze</a>(evbuf, 1);</div>
<div class="line"><span class="lineno">  146</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a5c24f3bfbc941d693bf59b5d77d2c37f">evbuffer_drain</a>(evbuf, nBytes);</div>
<div class="line"><span class="lineno">  147</span>    <a class="code hl_function" href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a>(buf,<a class="code hl_define" href="evbuffer-internal_8h.html#a3d6334db161ef939ed7ffff0f1f1c7b5">EVBUFFER_MEM_PINNED_W</a>);</div>
<div class="line"><span class="lineno">  148</span>    buf-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a> = 0;</div>
<div class="line"><span class="lineno">  149</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a3ac07b1be4b6fe0b2aa6a1677b060a80">evbuffer_decref_and_unlock_</a>(evbuf);</div>
<div class="line"><span class="lineno">  150</span>}</div>
<div class="ttc" id="aevbuffer-internal_8h_html_a3d6334db161ef939ed7ffff0f1f1c7b5"><div class="ttname"><a href="evbuffer-internal_8h.html#a3d6334db161ef939ed7ffff0f1f1c7b5">EVBUFFER_MEM_PINNED_W</a></div><div class="ttdeci">#define EVBUFFER_MEM_PINNED_W</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00196">evbuffer-internal.h:196</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a5c24f3bfbc941d693bf59b5d77d2c37f"><div class="ttname"><a href="libevent_2buffer_8c.html#a5c24f3bfbc941d693bf59b5d77d2c37f">evbuffer_drain</a></div><div class="ttdeci">int evbuffer_drain(struct evbuffer *buf, size_t len)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l01101">buffer.c:1101</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="libevent_2buffer_8c_source.html#l00561">evbuffer_decref_and_unlock_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l01101">evbuffer_drain()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00285">EVBUFFER_LOCK</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00196">EVBUFFER_MEM_PINNED_W</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03413">evbuffer_unfreeze()</a>, <a class="el" href="util-internal_8h_source.html#l00363">EVUTIL_ASSERT</a>, <a class="el" href="buffer__iocp_8c_source.html#l00084">pin_release()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00060">evbuffer_overlapped::read_in_progress</a>, <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00061">evbuffer_overlapped::write_in_progress</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00500">write_complete()</a>.</p>

</div>
</div>
<a id="ad818d436374dfa11f65abb2ac42d0f61" name="ad818d436374dfa11f65abb2ac42d0f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad818d436374dfa11f65abb2ac42d0f61">&#9670;&nbsp;</a></span>evbuffer_launch_read_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_launch_read_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__overlapped.html">event_overlapped</a> *&#160;</td>
          <td class="paramname"><em>ol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start reading data onto the end of an overlapped evbuffer.</p>
<p >An evbuffer can only have one read pending at a time. While the read is in progress, no other data may be added to the end of the buffer. The buffer must be created with <a class="el" href="iocp-internal_8h.html#a53365e4b680ce23d850fd0a43c8c1d1d">event_overlapped_init_()</a>. <a class="el" href="iocp-internal_8h.html#a99635a9183bcc42410f2cdf322873859">evbuffer_commit_read_()</a> must be called in the completion callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to read onto </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to try to read. </td></tr>
    <tr><td class="paramname">ol</td><td>Overlapped object with associated completion callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00246">246</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  248</span>{</div>
<div class="line"><span class="lineno">  249</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf_o = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(buf);</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordtype">int</span> r = -1, i;</div>
<div class="line"><span class="lineno">  251</span>    <span class="keywordtype">int</span> nvecs;</div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordtype">int</span> npin=0;</div>
<div class="line"><span class="lineno">  253</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__chain.html">evbuffer_chain</a> *chain=NULL, **chainp;</div>
<div class="line"><span class="lineno">  254</span>    DWORD bytesRead;</div>
<div class="line"><span class="lineno">  255</span>    DWORD <a class="code hl_variable" href="structevbuffer__chain.html#a5f5fd17d81d5c58ccb4113857115130f">flags</a> = 0;</div>
<div class="line"><span class="lineno">  256</span>    <span class="keyword">struct </span>evbuffer_iovec vecs[<a class="code hl_define" href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a>];</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">if</span> (!buf_o)</div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="lineno">  260</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a>(buf);</div>
<div class="line"><span class="lineno">  261</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(!buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a>);</div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">if</span> (buf-&gt;<a class="code hl_variable" href="structevbuffer.html#a6bed33d6f3074d83a5c39a21b3acbaf1">freeze_end</a> || buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a>)</div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  264</span> </div>
<div class="line"><span class="lineno">  265</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">first_pinned</a> = NULL;</div>
<div class="line"><span class="lineno">  266</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a> = 0;</div>
<div class="line"><span class="lineno">  267</span>    memset(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>, 0, <span class="keyword">sizeof</span>(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>));</div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="libevent_2buffer_8c.html#a0169295592d02008ef6229de9ba8a79b">evbuffer_expand_fast_</a>(buf, at_most, <a class="code hl_define" href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a>) == -1)</div>
<div class="line"><span class="lineno">  270</span>        <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  271</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#ab20a3648e696af4de0f4f183eaf190f4">evbuffer_freeze</a>(buf, 0);</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>    nvecs = <a class="code hl_function" href="libevent_2buffer_8c.html#a2c28b535591bbd5a33a3e5e00ba9b1c7">evbuffer_read_setup_vecs_</a>(buf, at_most,</div>
<div class="line"><span class="lineno">  274</span>        vecs, <a class="code hl_define" href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a>, &amp;chainp, 1);</div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">for</span> (i=0;i&lt;nvecs;++i) {</div>
<div class="line"><span class="lineno">  276</span>        <a class="code hl_define" href="evbuffer-internal_8h.html#a65d8385549fea2f6a752537b4679ba3d">WSABUF_FROM_EVBUFFER_IOV</a>(</div>
<div class="line"><span class="lineno">  277</span>            &amp;buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>[i],</div>
<div class="line"><span class="lineno">  278</span>            &amp;vecs[i]);</div>
<div class="line"><span class="lineno">  279</span>    }</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a> = nvecs;</div>
<div class="line"><span class="lineno">  282</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">first_pinned</a> = chain = *chainp;</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>    npin=0;</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">for</span> ( ; chain; chain = chain-&gt;<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>) {</div>
<div class="line"><span class="lineno">  286</span>        <a class="code hl_function" href="libevent_2buffer_8c.html#afe0cf08c219c3f30a28929846277b90b">evbuffer_chain_pin_</a>(chain, <a class="code hl_define" href="evbuffer-internal_8h.html#a07f97541f1b57f6ab70af2c555749161">EVBUFFER_MEM_PINNED_R</a>);</div>
<div class="line"><span class="lineno">  287</span>        ++npin;</div>
<div class="line"><span class="lineno">  288</span>    }</div>
<div class="line"><span class="lineno">  289</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(npin == nvecs);</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a28d71fa071cae93e6b7a64314283e921">evbuffer_incref_</a>(buf);</div>
<div class="line"><span class="lineno">  292</span>    <span class="keywordflow">if</span> (WSARecv(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a>, buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>, nvecs, &amp;bytesRead, &amp;flags,</div>
<div class="line"><span class="lineno">  293</span>            &amp;ol-&gt;overlapped, NULL)) {</div>
<div class="line"><span class="lineno">  294</span>        <span class="keywordtype">int</span> error = WSAGetLastError();</div>
<div class="line"><span class="lineno">  295</span>        <span class="keywordflow">if</span> (error != WSA_IO_PENDING) {</div>
<div class="line"><span class="lineno">  296</span>            <span class="comment">/* An actual error. */</span></div>
<div class="line"><span class="lineno">  297</span>            <a class="code hl_function" href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a>(buf_o, <a class="code hl_define" href="evbuffer-internal_8h.html#a07f97541f1b57f6ab70af2c555749161">EVBUFFER_MEM_PINNED_R</a>);</div>
<div class="line"><span class="lineno">  298</span>            <a class="code hl_function" href="libevent_2buffer_8c.html#ae1aa94b12221a02fcacc2f5dbf0f28b5">evbuffer_unfreeze</a>(buf, 0);</div>
<div class="line"><span class="lineno">  299</span>            <a class="code hl_function" href="libevent_2buffer_8c.html#ab27f081c089aebd2536296c13d53f735">evbuffer_free</a>(buf); <span class="comment">/* decref */</span></div>
<div class="line"><span class="lineno">  300</span>            <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  301</span>        }</div>
<div class="line"><span class="lineno">  302</span>    }</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a> = 1;</div>
<div class="line"><span class="lineno">  305</span>    r = 0;</div>
<div class="line"><span class="lineno">  306</span>done:</div>
<div class="line"><span class="lineno">  307</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a7d4b06a7e3d8b4e945cd3234328e39d7">EVBUFFER_UNLOCK</a>(buf);</div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">return</span> r;</div>
<div class="line"><span class="lineno">  309</span>}</div>
<div class="ttc" id="abuffer__iocp_8c_html_a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe"><div class="ttname"><a href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a></div><div class="ttdeci">#define MAX_WSABUFS</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00051">buffer_iocp.c:51</a></div></div>
<div class="ttc" id="aevbuffer-internal_8h_html_a65d8385549fea2f6a752537b4679ba3d"><div class="ttname"><a href="evbuffer-internal_8h.html#a65d8385549fea2f6a752537b4679ba3d">WSABUF_FROM_EVBUFFER_IOV</a></div><div class="ttdeci">#define WSABUF_FROM_EVBUFFER_IOV(i, ei)</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00330">evbuffer-internal.h:330</a></div></div>
<div class="ttc" id="aevbuffer-internal_8h_html_a7d4b06a7e3d8b4e945cd3234328e39d7"><div class="ttname"><a href="evbuffer-internal_8h.html#a7d4b06a7e3d8b4e945cd3234328e39d7">EVBUFFER_UNLOCK</a></div><div class="ttdeci">#define EVBUFFER_UNLOCK(buffer)</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00289">evbuffer-internal.h:289</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a0169295592d02008ef6229de9ba8a79b"><div class="ttname"><a href="libevent_2buffer_8c.html#a0169295592d02008ef6229de9ba8a79b">evbuffer_expand_fast_</a></div><div class="ttdeci">int evbuffer_expand_fast_(struct evbuffer *buf, size_t datlen, int n)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l02051">buffer.c:2051</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a28d71fa071cae93e6b7a64314283e921"><div class="ttname"><a href="libevent_2buffer_8c.html#a28d71fa071cae93e6b7a64314283e921">evbuffer_incref_</a></div><div class="ttdeci">void evbuffer_incref_(struct evbuffer *buf)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00396">buffer.c:396</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_a2c28b535591bbd5a33a3e5e00ba9b1c7"><div class="ttname"><a href="libevent_2buffer_8c.html#a2c28b535591bbd5a33a3e5e00ba9b1c7">evbuffer_read_setup_vecs_</a></div><div class="ttdeci">int evbuffer_read_setup_vecs_(struct evbuffer *buf, ev_ssize_t howmuch, struct evbuffer_iovec *vecs, int n_vecs_avail, struct evbuffer_chain ***chainp, int exact)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l02225">buffer.c:2225</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_ab20a3648e696af4de0f4f183eaf190f4"><div class="ttname"><a href="libevent_2buffer_8c.html#ab20a3648e696af4de0f4f183eaf190f4">evbuffer_freeze</a></div><div class="ttdeci">int evbuffer_freeze(struct evbuffer *buffer, int start)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l03401">buffer.c:3401</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_ab27f081c089aebd2536296c13d53f735"><div class="ttname"><a href="libevent_2buffer_8c.html#ab27f081c089aebd2536296c13d53f735">evbuffer_free</a></div><div class="ttdeci">void evbuffer_free(struct evbuffer *buffer)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00588">buffer.c:588</a></div></div>
<div class="ttc" id="alibevent_2buffer_8c_html_afe0cf08c219c3f30a28929846277b90b"><div class="ttname"><a href="libevent_2buffer_8c.html#afe0cf08c219c3f30a28929846277b90b">evbuffer_chain_pin_</a></div><div class="ttdeci">void evbuffer_chain_pin_(struct evbuffer_chain *chain, unsigned flag)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00340">buffer.c:340</a></div></div>
<div class="ttc" id="astructevbuffer__chain_html_a5f5fd17d81d5c58ccb4113857115130f"><div class="ttname"><a href="structevbuffer__chain.html#a5f5fd17d81d5c58ccb4113857115130f">evbuffer_chain::flags</a></div><div class="ttdeci">unsigned flags</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00188">evbuffer-internal.h:188</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a7b9d0b3e7ca35b2f372561a46f8359b2"><div class="ttname"><a href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">evbuffer_overlapped::first_pinned</a></div><div class="ttdeci">struct evbuffer_chain * first_pinned</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00064">buffer_iocp.c:64</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_aa702a7605d0bf4fbb79fe999d1c8d043"><div class="ttname"><a href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">evbuffer_overlapped::fd</a></div><div class="ttdeci">evutil_socket_t fd</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00057">buffer_iocp.c:57</a></div></div>
<div class="ttc" id="astructevbuffer_html_a6bed33d6f3074d83a5c39a21b3acbaf1"><div class="ttname"><a href="structevbuffer.html#a6bed33d6f3074d83a5c39a21b3acbaf1">evbuffer::freeze_end</a></div><div class="ttdeci">unsigned freeze_end</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00123">evbuffer-internal.h:123</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__iocp_8c_source.html#l00069">evbuffer_overlapped::buffers</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00340">evbuffer_chain_pin_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l02051">evbuffer_expand_fast_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00588">evbuffer_free()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03401">evbuffer_freeze()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00396">evbuffer_incref_()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00285">EVBUFFER_LOCK</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00195">EVBUFFER_MEM_PINNED_R</a>, <a class="el" href="libevent_2buffer_8c_source.html#l02225">evbuffer_read_setup_vecs_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03413">evbuffer_unfreeze()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00289">EVBUFFER_UNLOCK</a>, <a class="el" href="util-internal_8h_source.html#l00363">EVUTIL_ASSERT</a>, <a class="el" href="buffer__iocp_8c_source.html#l00057">evbuffer_overlapped::fd</a>, <a class="el" href="buffer__iocp_8c_source.html#l00064">evbuffer_overlapped::first_pinned</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00188">evbuffer_chain::flags</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00123">evbuffer::freeze_end</a>, <a class="el" href="buffer__iocp_8c_source.html#l00051">MAX_WSABUFS</a>, <a class="el" href="buffer__iocp_8c_source.html#l00068">evbuffer_overlapped::n_buffers</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00173">evbuffer_chain::next</a>, <a class="el" href="buffer__iocp_8c_source.html#l00084">pin_release()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00060">evbuffer_overlapped::read_in_progress</a>, <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00061">evbuffer_overlapped::write_in_progress</a>, and <a class="el" href="evbuffer-internal_8h_source.html#l00330">WSABUF_FROM_EVBUFFER_IOV</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00251">bev_async_consider_reading()</a>.</p>

</div>
</div>
<a id="aea2f1c3f3a08955cf2a209dd3549efe7" name="aea2f1c3f3a08955cf2a209dd3549efe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2f1c3f3a08955cf2a209dd3549efe7">&#9670;&nbsp;</a></span>evbuffer_launch_write_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_launch_write_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_ssize_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent__overlapped.html">event_overlapped</a> *&#160;</td>
          <td class="paramname"><em>ol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Start writing data from the start of an evbuffer.</p>
<p >An evbuffer can only have one write pending at a time. While the write is in progress, no other data may be removed from the front of the buffer. The buffer must be created with <a class="el" href="iocp-internal_8h.html#a53365e4b680ce23d850fd0a43c8c1d1d">event_overlapped_init_()</a>. <a class="el" href="iocp-internal_8h.html#a34fb1f37dc24cd9bb3d0461f7b7bebf9">evbuffer_commit_write_()</a> must be called in the completion callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to read onto </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to try to read. </td></tr>
    <tr><td class="paramname">ol</td><td>Overlapped object with associated completion callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00172">172</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>{</div>
<div class="line"><span class="lineno">  175</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf_o = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(buf);</div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordtype">int</span> r = -1;</div>
<div class="line"><span class="lineno">  177</span>    <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="lineno">  178</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__chain.html">evbuffer_chain</a> *chain;</div>
<div class="line"><span class="lineno">  179</span>    DWORD bytesSent;</div>
<div class="line"><span class="lineno">  180</span> </div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">if</span> (!buf) {</div>
<div class="line"><span class="lineno">  182</span>        <span class="comment">/* No buffer, or it isn&#39;t overlapped */</span></div>
<div class="line"><span class="lineno">  183</span>        <span class="keywordflow">return</span> -1;</div>
<div class="line"><span class="lineno">  184</span>    }</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a>(buf);</div>
<div class="line"><span class="lineno">  187</span>    <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(!buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a0d572b7b2208fa8ae9af987879077f4e">read_in_progress</a>);</div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">if</span> (buf-&gt;<a class="code hl_variable" href="structevbuffer.html#a082d569d992120cf9ff28ddb0f5da313">freeze_start</a> || buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a>)</div>
<div class="line"><span class="lineno">  189</span>        <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">if</span> (!buf-&gt;<a class="code hl_variable" href="structevbuffer.html#af432b67ab2e1b3dd8b96e314a0785116">total_len</a>) {</div>
<div class="line"><span class="lineno">  191</span>        <span class="comment">/* Nothing to write */</span></div>
<div class="line"><span class="lineno">  192</span>        r = 0;</div>
<div class="line"><span class="lineno">  193</span>        <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  194</span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (at_most &lt; 0 || (<span class="keywordtype">size_t</span>)at_most &gt; buf-&gt;<a class="code hl_variable" href="structevbuffer.html#af432b67ab2e1b3dd8b96e314a0785116">total_len</a>) {</div>
<div class="line"><span class="lineno">  195</span>        at_most = buf-&gt;<a class="code hl_variable" href="structevbuffer.html#af432b67ab2e1b3dd8b96e314a0785116">total_len</a>;</div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#ab20a3648e696af4de0f4f183eaf190f4">evbuffer_freeze</a>(buf, 1);</div>
<div class="line"><span class="lineno">  198</span> </div>
<div class="line"><span class="lineno">  199</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">first_pinned</a> = NULL;</div>
<div class="line"><span class="lineno">  200</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a> = 0;</div>
<div class="line"><span class="lineno">  201</span>    memset(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>, 0, <span class="keyword">sizeof</span>(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>));</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    chain = buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">first_pinned</a> = buf-&gt;<a class="code hl_variable" href="structevbuffer.html#a590cd5dc76dfecc57b45262d65fa1106">first</a>;</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">for</span> (i=0; i &lt; <a class="code hl_define" href="buffer__iocp_8c.html#a6ccfc8e6c4a3c3e1b42d0d0ff5d507fe">MAX_WSABUFS</a> &amp;&amp; chain; ++i, chain=chain-&gt;<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>) {</div>
<div class="line"><span class="lineno">  206</span>        WSABUF *b = &amp;buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>[i];</div>
<div class="line"><span class="lineno">  207</span>        b-&gt;buf = (<span class="keywordtype">char</span>*)( chain-&gt;buffer + chain-&gt;misalign );</div>
<div class="line"><span class="lineno">  208</span>        <a class="code hl_function" href="libevent_2buffer_8c.html#afe0cf08c219c3f30a28929846277b90b">evbuffer_chain_pin_</a>(chain, <a class="code hl_define" href="evbuffer-internal_8h.html#a3d6334db161ef939ed7ffff0f1f1c7b5">EVBUFFER_MEM_PINNED_W</a>);</div>
<div class="line"><span class="lineno">  209</span> </div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)at_most &gt; chain-&gt;off) {</div>
<div class="line"><span class="lineno">  211</span>            <span class="comment">/* XXXX Cast is safe for now, since win32 has no</span></div>
<div class="line"><span class="lineno">  212</span><span class="comment">               mmaped chains.  But later, we need to have this</span></div>
<div class="line"><span class="lineno">  213</span><span class="comment">               add more WSAbufs if chain-&gt;off is greater than</span></div>
<div class="line"><span class="lineno">  214</span><span class="comment">               ULONG_MAX */</span></div>
<div class="line"><span class="lineno">  215</span>            b-&gt;len = (<span class="keywordtype">unsigned</span> long)chain-&gt;off;</div>
<div class="line"><span class="lineno">  216</span>            at_most -= chain-&gt;off;</div>
<div class="line"><span class="lineno">  217</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  218</span>            b-&gt;len = (<span class="keywordtype">unsigned</span> long)at_most;</div>
<div class="line"><span class="lineno">  219</span>            ++i;</div>
<div class="line"><span class="lineno">  220</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  221</span>        }</div>
<div class="line"><span class="lineno">  222</span>    }</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a> = i;</div>
<div class="line"><span class="lineno">  225</span>    <a class="code hl_function" href="libevent_2buffer_8c.html#a28d71fa071cae93e6b7a64314283e921">evbuffer_incref_</a>(buf);</div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">if</span> (WSASend(buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a>, buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a063b9ed7a996656f391abaf6ad157344">buffers</a>, i, &amp;bytesSent, 0,</div>
<div class="line"><span class="lineno">  227</span>        &amp;ol-&gt;overlapped, NULL)) {</div>
<div class="line"><span class="lineno">  228</span>        <span class="keywordtype">int</span> error = WSAGetLastError();</div>
<div class="line"><span class="lineno">  229</span>        <span class="keywordflow">if</span> (error != WSA_IO_PENDING) {</div>
<div class="line"><span class="lineno">  230</span>            <span class="comment">/* An actual error. */</span></div>
<div class="line"><span class="lineno">  231</span>            <a class="code hl_function" href="buffer__iocp_8c.html#abd3499e3a8f974c5116ffac6aec8a211">pin_release</a>(buf_o, <a class="code hl_define" href="evbuffer-internal_8h.html#a3d6334db161ef939ed7ffff0f1f1c7b5">EVBUFFER_MEM_PINNED_W</a>);</div>
<div class="line"><span class="lineno">  232</span>            <a class="code hl_function" href="libevent_2buffer_8c.html#ae1aa94b12221a02fcacc2f5dbf0f28b5">evbuffer_unfreeze</a>(buf, 1);</div>
<div class="line"><span class="lineno">  233</span>            <a class="code hl_function" href="libevent_2buffer_8c.html#ab27f081c089aebd2536296c13d53f735">evbuffer_free</a>(buf); <span class="comment">/* decref */</span></div>
<div class="line"><span class="lineno">  234</span>            <span class="keywordflow">goto</span> done;</div>
<div class="line"><span class="lineno">  235</span>        }</div>
<div class="line"><span class="lineno">  236</span>    }</div>
<div class="line"><span class="lineno">  237</span> </div>
<div class="line"><span class="lineno">  238</span>    buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a07693e76fedfbd0227a2591c62749867">write_in_progress</a> = 1;</div>
<div class="line"><span class="lineno">  239</span>    r = 0;</div>
<div class="line"><span class="lineno">  240</span>done:</div>
<div class="line"><span class="lineno">  241</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a7d4b06a7e3d8b4e945cd3234328e39d7">EVBUFFER_UNLOCK</a>(buf);</div>
<div class="line"><span class="lineno">  242</span>    <span class="keywordflow">return</span> r;</div>
<div class="line"><span class="lineno">  243</span>}</div>
<div class="ttc" id="astructevbuffer_html_a082d569d992120cf9ff28ddb0f5da313"><div class="ttname"><a href="structevbuffer.html#a082d569d992120cf9ff28ddb0f5da313">evbuffer::freeze_start</a></div><div class="ttdeci">unsigned freeze_start</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00120">evbuffer-internal.h:120</a></div></div>
<div class="ttc" id="astructevbuffer_html_a590cd5dc76dfecc57b45262d65fa1106"><div class="ttname"><a href="structevbuffer.html#a590cd5dc76dfecc57b45262d65fa1106">evbuffer::first</a></div><div class="ttdeci">struct evbuffer_chain * first</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00082">evbuffer-internal.h:82</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="evbuffer-internal_8h_source.html#l00213">evbuffer_chain::buffer</a>, <a class="el" href="buffer__iocp_8c_source.html#l00069">evbuffer_overlapped::buffers</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00340">evbuffer_chain_pin_()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00588">evbuffer_free()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03401">evbuffer_freeze()</a>, <a class="el" href="libevent_2buffer_8c_source.html#l00396">evbuffer_incref_()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00285">EVBUFFER_LOCK</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00196">EVBUFFER_MEM_PINNED_W</a>, <a class="el" href="libevent_2buffer_8c_source.html#l03413">evbuffer_unfreeze()</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00289">EVBUFFER_UNLOCK</a>, <a class="el" href="util-internal_8h_source.html#l00363">EVUTIL_ASSERT</a>, <a class="el" href="buffer__iocp_8c_source.html#l00057">evbuffer_overlapped::fd</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00082">evbuffer::first</a>, <a class="el" href="buffer__iocp_8c_source.html#l00064">evbuffer_overlapped::first_pinned</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00120">evbuffer::freeze_start</a>, <a class="el" href="buffer__iocp_8c_source.html#l00051">MAX_WSABUFS</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00180">evbuffer_chain::misalign</a>, <a class="el" href="buffer__iocp_8c_source.html#l00068">evbuffer_overlapped::n_buffers</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00173">evbuffer_chain::next</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00185">evbuffer_chain::off</a>, <a class="el" href="buffer__iocp_8c_source.html#l00084">pin_release()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00060">evbuffer_overlapped::read_in_progress</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00102">evbuffer::total_len</a>, <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00061">evbuffer_overlapped::write_in_progress</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00207">bev_async_consider_writing()</a>.</p>

</div>
</div>
<a id="aaffb1fe62fb6146de08b63dce4597a53" name="aaffb1fe62fb6146de08b63dce4597a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffb1fe62fb6146de08b63dce4597a53">&#9670;&nbsp;</a></span>evbuffer_overlapped_get_fd_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">evutil_socket_t evbuffer_overlapped_get_fd_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >XXXX Document (nickm) </p>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00312">312</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  313</span>{</div>
<div class="line"><span class="lineno">  314</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf_o = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(buf);</div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">return</span> buf_o ? buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a> : -1;</div>
<div class="line"><span class="lineno">  316</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__iocp_8c_source.html#l00057">evbuffer_overlapped::fd</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00665">be_async_ctrl()</a>, <a class="el" href="bufferevent__async_8c_source.html#l00393">be_async_destruct()</a>, <a class="el" href="bufferevent__async_8c_source.html#l00416">bev_async_set_wsa_error()</a>, and <a class="el" href="bufferevent__async_8c_source.html#l00433">connect_complete()</a>.</p>

</div>
</div>
<a id="a473ad3c37c6b8af9f56f9ccda2a2ac8d" name="a473ad3c37c6b8af9f56f9ccda2a2ac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473ad3c37c6b8af9f56f9ccda2a2ac8d">&#9670;&nbsp;</a></span>evbuffer_overlapped_new_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a> * evbuffer_overlapped_new_ </td>
          <td>(</td>
          <td class="paramtype">evutil_socket_t&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate and return a new evbuffer that supports overlapped IO on a given socket. The socket must be associated with an IO completion port using event_iocp_port_associate_. </p>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00153">153</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  154</span>{</div>
<div class="line"><span class="lineno">  155</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *evo;</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    evo = <a class="code hl_define" href="mm-internal_8h.html#a0c64a2a6527ed776255e0e4e380593dc">mm_calloc</a>(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a>));</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">if</span> (!evo)</div>
<div class="line"><span class="lineno">  159</span>        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">  160</span> </div>
<div class="line"><span class="lineno">  161</span>    LIST_INIT(&amp;evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>.callbacks);</div>
<div class="line"><span class="lineno">  162</span>    evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>.<a class="code hl_variable" href="structevbuffer.html#a84f258913691bdcc10456cfe78fe9440">refcnt</a> = 1;</div>
<div class="line"><span class="lineno">  163</span>    evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>.<a class="code hl_variable" href="structevbuffer.html#aa89b72c7086750d7b6c91902e2f1bf21">last_with_datap</a> = &amp;evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>.<a class="code hl_variable" href="structevbuffer.html#a590cd5dc76dfecc57b45262d65fa1106">first</a>;</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>.is_overlapped = 1;</div>
<div class="line"><span class="lineno">  166</span>    evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a> = <a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a>;</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordflow">return</span> &amp;evo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">buffer</a>;</div>
<div class="line"><span class="lineno">  169</span>}</div>
<div class="ttc" id="amm-internal_8h_html_a0c64a2a6527ed776255e0e4e380593dc"><div class="ttname"><a href="mm-internal_8h.html#a0c64a2a6527ed776255e0e4e380593dc">mm_calloc</a></div><div class="ttdeci">#define mm_calloc(count, size)</div><div class="ttdef"><b>Definition:</b> <a href="mm-internal_8h_source.html#l00076">mm-internal.h:76</a></div></div>
<div class="ttc" id="astructevbuffer__overlapped_html_a2d56afb55a85e65576c6e350ccd7f87b"><div class="ttname"><a href="structevbuffer__overlapped.html#a2d56afb55a85e65576c6e350ccd7f87b">evbuffer_overlapped::buffer</a></div><div class="ttdeci">struct evbuffer buffer</div><div class="ttdef"><b>Definition:</b> <a href="buffer__iocp_8c_source.html#l00055">buffer_iocp.c:55</a></div></div>
<div class="ttc" id="astructevbuffer_html_a84f258913691bdcc10456cfe78fe9440"><div class="ttname"><a href="structevbuffer.html#a84f258913691bdcc10456cfe78fe9440">evbuffer::refcnt</a></div><div class="ttdeci">int refcnt</div><div class="ttdef"><b>Definition:</b> <a href="evbuffer-internal_8h_source.html#l00144">evbuffer-internal.h:144</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__iocp_8c_source.html#l00055">evbuffer_overlapped::buffer</a>, <a class="el" href="buffer__iocp_8c_source.html#l00057">evbuffer_overlapped::fd</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00082">evbuffer::first</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00099">evbuffer::last_with_datap</a>, <a class="el" href="mm-internal_8h_source.html#l00076">mm_calloc</a>, and <a class="el" href="evbuffer-internal_8h_source.html#l00144">evbuffer::refcnt</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00543">bufferevent_async_new_()</a>.</p>

</div>
</div>
<a id="a93de139bbf95596c3018542c8bfb45a8" name="a93de139bbf95596c3018542c8bfb45a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93de139bbf95596c3018542c8bfb45a8">&#9670;&nbsp;</a></span>evbuffer_overlapped_set_fd_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_overlapped_set_fd_ </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evutil_socket_t&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00319">319</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  320</span>{</div>
<div class="line"><span class="lineno">  321</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *buf_o = <a class="code hl_function" href="buffer__iocp_8c.html#a2392eb7397eb609061e172efebbe1f22">upcast_evbuffer</a>(buf);</div>
<div class="line"><span class="lineno">  322</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a2db7168a100510b09c26d9d9896991e0">EVBUFFER_LOCK</a>(buf);</div>
<div class="line"><span class="lineno">  323</span>    <span class="comment">/* XXX is this right?, should it cancel current I/O operations? */</span></div>
<div class="line"><span class="lineno">  324</span>    <span class="keywordflow">if</span> (buf_o)</div>
<div class="line"><span class="lineno">  325</span>        buf_o-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a> = <a class="code hl_variable" href="structevbuffer__overlapped.html#aa702a7605d0bf4fbb79fe999d1c8d043">fd</a>;</div>
<div class="line"><span class="lineno">  326</span>    <a class="code hl_define" href="evbuffer-internal_8h.html#a7d4b06a7e3d8b4e945cd3234328e39d7">EVBUFFER_UNLOCK</a>(buf);</div>
<div class="line"><span class="lineno">  327</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="evbuffer-internal_8h_source.html#l00285">EVBUFFER_LOCK</a>, <a class="el" href="evbuffer-internal_8h_source.html#l00289">EVBUFFER_UNLOCK</a>, <a class="el" href="buffer__iocp_8c_source.html#l00057">evbuffer_overlapped::fd</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00075">upcast_evbuffer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="bufferevent__async_8c_source.html#l00665">be_async_ctrl()</a>, and <a class="el" href="bufferevent__async_8c_source.html#l00393">be_async_destruct()</a>.</p>

</div>
</div>
<a id="abd3499e3a8f974c5116ffac6aec8a211" name="abd3499e3a8f974c5116ffac6aec8a211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3499e3a8f974c5116ffac6aec8a211">&#9670;&nbsp;</a></span>pin_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pin_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> *&#160;</td>
          <td class="paramname"><em>eo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Unpin all the chains noted as pinned in 'eo'. </p>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00084">84</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   85</span>{</div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="lineno">   87</span>    <span class="keyword">struct </span><a class="code hl_struct" href="structevbuffer__chain.html">evbuffer_chain</a> *<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>, *chain = eo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a7b9d0b3e7ca35b2f372561a46f8359b2">first_pinned</a>;</div>
<div class="line"><span class="lineno">   88</span> </div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">for</span> (i = 0; i &lt; eo-&gt;<a class="code hl_variable" href="structevbuffer__overlapped.html#a5418e2c9cd900c2135fe3320ad300b11">n_buffers</a>; ++i) {</div>
<div class="line"><span class="lineno">   90</span>        <a class="code hl_define" href="util-internal_8h.html#a7365930d8b30f4c1ab3cef31a8622731">EVUTIL_ASSERT</a>(chain);</div>
<div class="line"><span class="lineno">   91</span>        <a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a> = chain-&gt;<a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>;</div>
<div class="line"><span class="lineno">   92</span>        <a class="code hl_function" href="libevent_2buffer_8c.html#ac949f855421b4afd676f3293b4d8706e">evbuffer_chain_unpin_</a>(chain, flag);</div>
<div class="line"><span class="lineno">   93</span>        chain = <a class="code hl_variable" href="structevbuffer__chain.html#a302eea17a6aacc55c33f119ad788ddb5">next</a>;</div>
<div class="line"><span class="lineno">   94</span>    }</div>
<div class="line"><span class="lineno">   95</span>}</div>
<div class="ttc" id="alibevent_2buffer_8c_html_ac949f855421b4afd676f3293b4d8706e"><div class="ttname"><a href="libevent_2buffer_8c.html#ac949f855421b4afd676f3293b4d8706e">evbuffer_chain_unpin_</a></div><div class="ttdeci">void evbuffer_chain_unpin_(struct evbuffer_chain *chain, unsigned flag)</div><div class="ttdef"><b>Definition:</b> <a href="libevent_2buffer_8c_source.html#l00347">buffer.c:347</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="libevent_2buffer_8c_source.html#l00347">evbuffer_chain_unpin_()</a>, <a class="el" href="util-internal_8h_source.html#l00363">EVUTIL_ASSERT</a>, <a class="el" href="buffer__iocp_8c_source.html#l00064">evbuffer_overlapped::first_pinned</a>, <a class="el" href="buffer__iocp_8c_source.html#l00068">evbuffer_overlapped::n_buffers</a>, and <a class="el" href="evbuffer-internal_8h_source.html#l00173">evbuffer_chain::next</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__iocp_8c_source.html#l00098">evbuffer_commit_read_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00139">evbuffer_commit_write_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00246">evbuffer_launch_read_()</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00172">evbuffer_launch_write_()</a>.</p>

</div>
</div>
<a id="a2392eb7397eb609061e172efebbe1f22" name="a2392eb7397eb609061e172efebbe1f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2392eb7397eb609061e172efebbe1f22">&#9670;&nbsp;</a></span>upcast_evbuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structevbuffer__overlapped.html">evbuffer_overlapped</a> * upcast_evbuffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Given an evbuffer, return the correponding evbuffer structure, or NULL if the evbuffer isn't overlapped. </p>

<p class="definition">Definition at line <a class="el" href="buffer__iocp_8c_source.html#l00075">75</a> of file <a class="el" href="buffer__iocp_8c_source.html">buffer_iocp.c</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   76</span>{</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">if</span> (!buf || !buf-&gt;is_overlapped)</div>
<div class="line"><span class="lineno">   78</span>        <span class="keywordflow">return</span> NULL;</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="util-internal_8h.html#a9b1285f7a3e9b52331e598415a98b5ef">EVUTIL_UPCAST</a>(buf, <span class="keyword">struct</span> <a class="code hl_struct" href="structevbuffer__overlapped.html">evbuffer_overlapped</a>, <a class="code hl_struct" href="structbuffer.html">buffer</a>);</div>
<div class="line"><span class="lineno">   80</span>}</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition:</b> <a href="buffer_8h_source.html#l00037">buffer.h:37</a></div></div>
<div class="ttc" id="autil-internal_8h_html_a9b1285f7a3e9b52331e598415a98b5ef"><div class="ttname"><a href="util-internal_8h.html#a9b1285f7a3e9b52331e598415a98b5ef">EVUTIL_UPCAST</a></div><div class="ttdeci">#define EVUTIL_UPCAST(ptr, type, field)</div><div class="ttdef"><b>Definition:</b> <a href="util-internal_8h_source.html#l00288">util-internal.h:288</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="util-internal_8h_source.html#l00288">EVUTIL_UPCAST</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__iocp_8c_source.html#l00098">evbuffer_commit_read_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00139">evbuffer_commit_write_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00246">evbuffer_launch_read_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00172">evbuffer_launch_write_()</a>, <a class="el" href="buffer__iocp_8c_source.html#l00312">evbuffer_overlapped_get_fd_()</a>, and <a class="el" href="buffer__iocp_8c_source.html#l00319">evbuffer_overlapped_set_fd_()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
